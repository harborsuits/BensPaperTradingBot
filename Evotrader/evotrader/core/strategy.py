"""Strategy abstract interface for EvoTrader."""

from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Tuple
import copy
import uuid
import json


class SignalType:
    """Enumeration of possible signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE = "close"


class Signal:
    """Trading signal generated by a strategy."""
    
    def __init__(self, 
                symbol: str, 
                signal_type: str,
                quantity: Optional[float] = None,
                price: Optional[float] = None,
                confidence: float = 1.0,
                reason: str = "",
                params: Optional[Dict[str, Any]] = None):
        """
        Initialize a trading signal.
        
        Args:
            symbol: Trading symbol (e.g. 'BTC/USD')
            signal_type: Type of signal (buy, sell, hold, close)
            quantity: Trading quantity (optional)
            price: Target price for limit orders (optional)
            confidence: Signal confidence level 0.0-1.0
            reason: Reasoning behind the signal
            params: Additional parameters for the signal
        """
        self.id = str(uuid.uuid4())
        self.symbol = symbol
        self.signal_type = signal_type
        self.quantity = quantity
        self.price = price
        self.confidence = min(max(confidence, 0.0), 1.0)  # Clamp between 0 and 1
        self.reason = reason
        self.params = params or {}
        self.timestamp = None  # Will be set when processed
    
    def __str__(self) -> str:
        return f"{self.signal_type.upper()} {self.quantity} {self.symbol} @ {self.price} (conf: {self.confidence:.2f})"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary for serialization."""
        return {
            "id": self.id,
            "symbol": self.symbol,
            "signal_type": self.signal_type,
            "quantity": self.quantity,
            "price": self.price,
            "confidence": self.confidence,
            "reason": self.reason,
            "params": self.params,
            "timestamp": self.timestamp
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Signal':
        """Create signal from dictionary."""
        signal = cls(
            symbol=data["symbol"],
            signal_type=data["signal_type"],
            quantity=data.get("quantity"),
            price=data.get("price"),
            confidence=data.get("confidence", 1.0),
            reason=data.get("reason", ""),
            params=data.get("params", {})
        )
        signal.id = data.get("id", signal.id)
        signal.timestamp = data.get("timestamp")
        return signal


class StrategyParameter:
    """Defines a parameter for a strategy, including mutation characteristics."""
    
    def __init__(self, 
                name: str, 
                default_value: Any,
                min_value: Optional[float] = None,
                max_value: Optional[float] = None,
                step: Optional[float] = None,
                is_mutable: bool = True,
                mutation_factor: float = 0.1):
        """
        Initialize a strategy parameter.
        
        Args:
            name: Parameter name
            default_value: Default value
            min_value: Minimum value (for numeric parameters)
            max_value: Maximum value (for numeric parameters)
            step: Step size for mutations (for numeric parameters)
            is_mutable: Whether this parameter can be mutated
            mutation_factor: How much to mutate this parameter
        """
        self.name = name
        self.default_value = default_value
        self.min_value = min_value
        self.max_value = max_value
        self.step = step
        self.is_mutable = is_mutable
        self.mutation_factor = mutation_factor
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert parameter specification to dictionary."""
        return {
            "name": self.name,
            "default_value": self.default_value,
            "min_value": self.min_value,
            "max_value": self.max_value,
            "step": self.step,
            "is_mutable": self.is_mutable,
            "mutation_factor": self.mutation_factor
        }


class Strategy(ABC):
    """Abstract base class for all trading strategies."""
    
    def __init__(self, strategy_id: Optional[str] = None, parameters: Optional[Dict[str, Any]] = None):
        """
        Initialize a strategy instance.
        
        Args:
            strategy_id: Unique identifier for this strategy instance
            parameters: Dictionary of parameter values
        """
        self.strategy_id = strategy_id or f"{self.__class__.__name__}_{str(uuid.uuid4())[:8]}"
        self.parameters = parameters or {}
        
        # Apply default parameters if not provided
        for param_def in self.get_parameters():
            if param_def.name not in self.parameters:
                self.parameters[param_def.name] = param_def.default_value
    
    @classmethod
    def get_parameters(cls) -> List[StrategyParameter]:
        """
        Get parameter definitions for this strategy.
        Should be overridden by concrete strategies.
        
        Returns:
            List of parameter definitions
        """
        return []
    
    def validate_parameters(self) -> Tuple[bool, List[str]]:
        """
        Validate current parameter values.
        
        Returns:
            Tuple of (is_valid, list_of_errors)
        """
        errors = []
        param_defs = {p.name: p for p in self.get_parameters()}
        
        for name, param_def in param_defs.items():
            if name not in self.parameters:
                errors.append(f"Missing required parameter: {name}")
                continue
                
            value = self.parameters[name]
            
            # Type checking could be added here
            
            # Range checking for numeric parameters
            if isinstance(value, (int, float)) and param_def.min_value is not None and param_def.max_value is not None:
                if value < param_def.min_value or value > param_def.max_value:
                    errors.append(f"Parameter {name} value {value} is outside allowed range: "
                                f"[{param_def.min_value}, {param_def.max_value}]")
        
        return len(errors) == 0, errors
    
    def clone(self) -> 'Strategy':
        """
        Create a clone of this strategy instance.
        
        Returns:
            A new strategy instance with the same parameters
        """
        cloned = self.__class__()
        cloned.parameters = copy.deepcopy(self.parameters)
        return cloned
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert strategy to dictionary for serialization.
        
        Returns:
            Dictionary representation of the strategy
        """
        return {
            "strategy_id": self.strategy_id,
            "strategy_type": self.__class__.__name__,
            "parameters": self.parameters
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Strategy':
        """
        Create strategy from dictionary.
        
        Args:
            data: Dictionary representation of the strategy
            
        Returns:
            Strategy instance
        """
        return cls(strategy_id=data.get("strategy_id"), parameters=data.get("parameters", {}))

    @abstractmethod
    def generate_signals(self, market_data: Dict[str, Any]) -> List[Signal]:
        """
        Decide trading actions based on market data.

        Args:
            market_data: Snapshot of market info (prices, volumes, etc.)

        Returns:
            List of trading signals to execute
        """
        pass
    
    def on_order_filled(self, order_data: Dict[str, Any]) -> None:
        """
        Called when an order generated by this strategy is filled.
        Can be used to update internal state.
        
        Args:
            order_data: Data about the filled order
        """
        pass
    
    def on_simulation_end(self) -> Dict[str, Any]:
        """
        Called at the end of a simulation run.
        Can be used to calculate final metrics or clean up.
        
        Returns:
            Dictionary with strategy-specific metrics
        """
        return {}
