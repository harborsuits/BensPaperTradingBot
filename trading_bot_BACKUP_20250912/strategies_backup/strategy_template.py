#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Strategy Template Module

This module provides base classes for defining trading strategies.
"""

import logging
import abc
from enum import Enum
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple, Union

logger = logging.getLogger(__name__)

class TimeFrame(Enum):
    """Enum for time frames."""
    MINUTE_1 = "1m"
    MINUTE_5 = "5m"
    MINUTE_15 = "15m"
    MINUTE_30 = "30m"
    HOUR_1 = "1h"
    HOUR_4 = "4h"
    DAY_1 = "1d"
    WEEK_1 = "1w"
    MONTH_1 = "1mo"

class SignalType(Enum):
    """Enum for signal types."""
    BUY = "buy"
    SELL = "sell"
    EXIT = "exit"
    NONE = "none"

class MarketRegime(Enum):
    """Enum for market regimes."""
    BULL_TREND = "bull_trend"
    BEAR_TREND = "bear_trend"
    CONSOLIDATION = "consolidation"
    HIGH_VOLATILITY = "high_volatility"
    LOW_VOLATILITY = "low_volatility"
    UNKNOWN = "unknown"

class Signal:
    """
    Class representing a trading signal generated by a strategy.
    """
    
    def __init__(self, 
                symbol: str,
                signal_type: SignalType,
                price: float,
                timestamp: datetime = None,
                confidence: float = 1.0,
                stop_loss: Optional[float] = None,
                take_profit: Optional[float] = None,
                timeframe: TimeFrame = TimeFrame.DAY_1,
                metadata: Optional[Dict[str, Any]] = None):
        """
        Initialize a Signal.
        
        Args:
            symbol: Trading symbol
            signal_type: Type of signal
            price: Current price at signal generation
            timestamp: Signal timestamp (default: current time)
            confidence: Confidence level (0.0-1.0)
            stop_loss: Suggested stop loss price
            take_profit: Suggested take profit price
            timeframe: Time frame for the signal
            metadata: Additional signal details
        """
        self.symbol = symbol
        self.signal_type = signal_type
        self.price = price
        self.timestamp = timestamp if timestamp else datetime.now()
        self.confidence = confidence  # 0.0 to 1.0
        self.stop_loss = stop_loss
        self.take_profit = take_profit
        self.timeframe = timeframe
        self.metadata = metadata or {}
    
    def __str__(self) -> str:
        """Return string representation of the signal."""
        signal_str = (
            f"Signal({self.symbol}, {self.signal_type.value}, "
            f"price=${self.price:.2f}, "
            f"confidence={self.confidence:.2f}, "
            f"time={self.timestamp.isoformat()})"
        )
        return signal_str
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            "symbol": self.symbol,
            "signal_type": self.signal_type.value,
            "price": self.price,
            "timestamp": self.timestamp.isoformat(),
            "confidence": self.confidence,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "timeframe": self.timeframe.value,
            "metadata": self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Signal':
        """Create a Signal from a dictionary."""
        return cls(
            symbol=data["symbol"],
            signal_type=SignalType(data["signal_type"]),
            price=data["price"],
            timestamp=datetime.fromisoformat(data["timestamp"]),
            confidence=data.get("confidence", 1.0),
            stop_loss=data.get("stop_loss"),
            take_profit=data.get("take_profit"),
            timeframe=TimeFrame(data.get("timeframe", "1d")),
            metadata=data.get("metadata", {})
        )

class StrategyTemplate(abc.ABC):
    """
    Abstract base class for all trading strategies.
    
    This class defines the interface that all strategies must implement.
    """
    
    def __init__(self, name: str, parameters: Optional[Dict[str, Any]] = None, 
               metadata: Optional[Dict[str, Any]] = None):
        """
        Initialize a Strategy.
        
        Args:
            name: Strategy name
            parameters: Strategy parameters
            metadata: Strategy metadata
        """
        self.name = name
        self.parameters = parameters or {}
        self.metadata = metadata or {}
        
        logger.info(f"Initialized strategy: {name}")
    
    @abc.abstractmethod
    def generate_signals(self, data: Dict[str, Any]) -> Dict[str, Signal]:
        """
        Generate trading signals based on the provided data.
        
        Args:
            data: Input data for signal generation
            
        Returns:
            Dictionary mapping symbols to Signal objects
        """
        pass
    
    def get_parameter(self, key: str, default: Any = None) -> Any:
        """
        Get a strategy parameter.
        
        Args:
            key: Parameter key
            default: Default value if parameter doesn't exist
            
        Returns:
            Parameter value or default
        """
        return self.parameters.get(key, default)
    
    def set_parameter(self, key: str, value: Any) -> None:
        """
        Set a strategy parameter.
        
        Args:
            key: Parameter key
            value: Parameter value
        """
        self.parameters[key] = value
        logger.debug(f"Set parameter {key}={value} for {self.name}")
    
    def set_parameters(self, parameters: Dict[str, Any]) -> None:
        """
        Set multiple strategy parameters.
        
        Args:
            parameters: Dictionary of parameters
        """
        self.parameters.update(parameters)
        logger.debug(f"Updated parameters for {self.name}: {parameters}")
    
    def get_metadata(self, key: str, default: Any = None) -> Any:
        """
        Get strategy metadata.
        
        Args:
            key: Metadata key
            default: Default value if metadata doesn't exist
            
        Returns:
            Metadata value or default
        """
        return self.metadata.get(key, default)
    
    def set_metadata(self, key: str, value: Any) -> None:
        """
        Set strategy metadata.
        
        Args:
            key: Metadata key
            value: Metadata value
        """
        self.metadata[key] = value

class StrategyOptimizable(StrategyTemplate):
    """
    Base class for trading strategies with parameter optimization capabilities.
    
    The StrategyOptimizable class extends the core StrategyTemplate by adding sophisticated
    parameter optimization capabilities. It provides a framework for systematic strategy 
    improvement through objective performance measurement and parameter space exploration.
    
    This class enables:
    1. Defining searchable parameter spaces for strategy optimization
    2. Evaluating strategy performance with different parameter combinations
    3. Optimizing parameters to find optimal configurations
    4. Measuring performance through customizable evaluation metrics
    5. Maintaining separation between optimization and execution logic
    
    Key optimization capabilities include:
    - Parameter space definition with constraints and granularity control
    - Flexible evaluation functions for different optimization objectives
    - Extensible optimization algorithm implementation
    - Cross-validation support to prevent overfitting
    - Performance comparison across parameter combinations
    
    Implementation considerations:
    - Child classes must override get_parameter_space() to define optimizable parameters
    - Child classes should implement _calculate_performance_score() with appropriate metrics
    - The optimize() method can be extended with more sophisticated algorithms
    - Consider computational efficiency when defining parameter spaces
    - Beware of overfitting risks when optimizing with limited historical data
    
    Trading strategy optimization involves balancing several critical factors:
    - Out-of-sample validation to ensure generalizability
    - Computational efficiency for practical implementation
    - Strategy robustness across different market regimes
    - Sensitivity analysis to understand parameter importance
    - Risk-adjusted performance metrics beyond raw returns
    
    Attributes:
        name (str): Strategy identifier name
        parameters (Dict[str, Any]): Current strategy parameters
        metadata (Dict[str, Any]): Additional strategy metadata and state information
    """
    
    def get_parameter_space(self) -> Dict[str, List[Any]]:
        """
        Define the parameter space for strategy optimization.
        
        This method specifies the parameters that can be optimized and their
        possible values. The parameter space is defined as a dictionary mapping
        parameter names to lists of possible values.
        
        The parameter space definition should consider:
        - Reasonable bounds for each parameter
        - Appropriate granularity for numerical parameters
        - Inclusion of only truly impactful parameters
        - Computational feasibility of the resulting search space
        
        Returns:
            Dict[str, List[Any]]: Dictionary mapping parameter names to lists of 
                possible values. For example:
                {
                    'fast_ma_period': [5, 10, 15, 20, 25],
                    'slow_ma_period': [20, 30, 40, 50, 60],
                    'rsi_threshold': [25, 30, 35, 40],
                    'stop_loss_pct': [0.02, 0.03, 0.04, 0.05]
                }
                
        Notes:
            - Override this method in child classes to define strategy-specific
              parameter spaces
            - Empty dictionary indicates no parameters to optimize
            - Consider the combinatorial explosion when defining multiple parameters
            - Parameters not included will remain fixed at their current values
        """
        # Override in subclasses
        return {}
    
    def evaluate(self, parameters: Dict[str, Any], data: Dict[str, Any]) -> float:
        """
        Evaluate strategy performance with the specified parameters.
        
        This method temporarily applies a set of parameters to the strategy,
        generates signals based on the input data, evaluates performance using
        the _calculate_performance_score method, and then restores the original
        parameters.
        
        The evaluation process:
        1. Stores the current parameters
        2. Applies the new parameters for testing
        3. Generates signals using the strategy with new parameters
        4. Calculates a performance score for these signals
        5. Restores the original parameters
        6. Returns the performance score
        
        Parameters:
            parameters (Dict[str, Any]): Strategy parameters to evaluate
            data (Dict[str, Any]): Input data for signal generation and evaluation,
                usually historical price and indicator data
            
        Returns:
            float: Performance score where higher values indicate better performance.
                The score can represent any appropriate metric such as:
                - Risk-adjusted returns (e.g., Sharpe ratio)
                - Absolute returns
                - Win rate or profit factor
                - Custom combination of multiple metrics
                
        Notes:
            - This method is non-destructive - it preserves the strategy's original parameters
            - The interpretation of the score depends on the implementation of
              _calculate_performance_score in the child class
            - Typically called many times during optimization
            - Consider performance implications for computationally intensive strategies
        """
        # Save original parameters
        original_parameters = self.parameters.copy()
        
        # Set evaluation parameters
        self.set_parameters(parameters)
        
        # Generate signals
        signals = self.generate_signals(data)
        
        # Calculate performance score (to be implemented by subclasses)
        score = self._calculate_performance_score(signals, data)
        
        # Restore original parameters
        self.parameters = original_parameters
        
        return score
    
    def _calculate_performance_score(self, signals: Dict[str, Signal], 
                                   data: Dict[str, Any]) -> float:
        """
        Calculate a performance score for a set of generated signals.
        
        This method evaluates the quality of signals generated by the strategy,
        typically by simulating trades based on the signals and calculating
        performance metrics. The specific implementation depends on the strategy's
        objectives and constraints.
        
        Common performance metrics include:
        - Risk-adjusted returns (Sharpe ratio, Sortino ratio, Calmar ratio)
        - Absolute returns or profits
        - Win rate, profit factor, or expectancy
        - Maximum drawdown or other risk measures
        - Custom combinations of multiple metrics
        
        Parameters:
            signals (Dict[str, Signal]): Dictionary mapping symbols to generated signals
            data (Dict[str, Any]): Input data used for evaluation, typically including
                historical price data to simulate signal execution
            
        Returns:
            float: Performance score where higher values indicate better performance
                
        Notes:
            - Must be implemented by child classes
            - The default implementation returns 0.0
            - Consider including risk adjustment in the score calculation
            - Balance between returns, risk, consistency, and robustness
            - May implement walk-forward validation to prevent overfitting
            - Can incorporate transaction costs and slippage for realistic evaluation
        """
        # Override in subclasses
        return 0.0
    
    def optimize(self, data: Dict[str, Any], iterations: int = 10) -> Tuple[Dict[str, Any], float]:
        """
        Optimize strategy parameters to maximize performance.
        
        This method explores the parameter space defined by get_parameter_space()
        to find parameter combinations that maximize the performance score.
        The default implementation uses simple random search, but subclasses
        can implement more sophisticated optimization algorithms.
        
        The optimization process:
        1. Defines the parameter space to search
        2. Repeatedly:
           a. Selects parameter combinations from the space
           b. Evaluates the strategy performance with those parameters
           c. Tracks the best performing parameters
        3. Returns the best parameters found and their score
        
        Advanced optimization approaches that could be implemented:
        - Grid search for exhaustive exploration of smaller parameter spaces
        - Genetic algorithms for evolutionary optimization
        - Bayesian optimization for efficient exploration
        - Particle swarm optimization for complex spaces
        - Simulated annealing for avoiding local optima
        
        Parameters:
            data (Dict[str, Any]): Input data for optimization, typically
                historical price and indicator data
            iterations (int): Number of parameter combinations to evaluate
            
        Returns:
            Tuple[Dict[str, Any], float]: A tuple containing:
                - The best performing parameters found
                - The corresponding performance score
                
        Notes:
            - Computationally intensive - consider runtime for large parameter spaces
            - Beware of overfitting risks when optimizing on limited historical data
            - Consider implementing cross-validation or walk-forward validation
            - The default random search implementation can be extended or replaced
            - Tracks previously evaluated parameter combinations to avoid duplication
        """
        # Get parameter space
        param_space = self.get_parameter_space()
        
        if not param_space:
            logger.warning(f"No parameter space defined for {self.name}")
            return self.parameters.copy(), 0.0
        
        # In a real implementation, this would use more sophisticated optimization techniques
        # like grid search, random search, genetic algorithms, Bayesian optimization, etc.
        # Here, we use a simple random search for demonstration
        
        import random
        
        best_score = float('-inf')
        best_params = self.parameters.copy()
        
        # Keep track of evaluated parameters
        evaluated_params = set()
        
        for _ in range(iterations):
            # Generate random parameters from the parameter space
            params = {}
            for param, values in param_space.items():
                if values:
                    params[param] = random.choice(values)
            
            # Skip if we've already evaluated these parameters
            param_key = str(sorted(params.items()))
            if param_key in evaluated_params:
                continue
                
            evaluated_params.add(param_key)
            
            # Start with current best parameters and update with new ones
            trial_params = best_params.copy()
            trial_params.update(params)
            
            # Evaluate parameters
            score = self.evaluate(trial_params, data)
            
            # Update best if better
            if score > best_score:
                best_score = score
                best_params = trial_params.copy()
                logger.info(f"New best parameters for {self.name}: score={best_score:.4f}, params={best_params}")
        
        return best_params, best_score 