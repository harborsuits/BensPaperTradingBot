#!/usr/bin/env python3
"""
Enhanced Strategy Manager

This module implements an advanced strategy management system that:
1. Loads and executes trading strategies
2. Provides event-driven data flow to strategies
3. Collects and processes trading signals
4. Enforces portfolio-level rules
5. Supports strategy ensembles with weighting
6. Implements dynamic strategy activation/deactivation

The manager operates in an event-driven loop, processing market data
and events through registered strategies while enforcing system-wide
risk controls and portfolio constraints.
"""

import logging
import importlib
import inspect
import json
import os
import uuid
import threading
import time
from collections import defaultdict
from datetime import datetime, timedelta
from enum import Enum
from typing import Dict, List, Any, Optional, Union, Tuple, Callable, Set, Type

from trading_bot.core.constants import EventType, AssetType
from trading_bot.core.event_bus import Event, get_global_event_bus, EventBus
from trading_bot.core.strategy_base import Strategy, StrategyState, StrategyType
from trading_bot.core.strategy_manager import StrategyPerformanceManager, StrategyStatus
from trading_bot.brokers.multi_broker_manager import MultiBrokerManager
from trading_bot.models.order import Order, OrderSide, OrderType
from trading_bot.models.position import Position
from trading_bot.models.portfolio import Portfolio

logger = logging.getLogger(__name__)


class SignalAction(Enum):
    """Enum defining possible signal actions."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE = "close"


class SignalStrength(Enum):
    """Enum defining signal strength levels."""
    STRONG = "strong"
    MODERATE = "moderate"
    WEAK = "weak"


class Signal:
    """Class representing a trading signal generated by a strategy."""
    
    def __init__(
        self,
        strategy_id: str,
        symbol: str,
        action: SignalAction,
        timestamp: datetime = None,
        strength: SignalStrength = SignalStrength.MODERATE,
        confidence: float = 0.5,
        target_price: float = None,
        stop_loss: float = None,
        take_profit: float = None,
        quantity: float = None,
        allocation: float = None,
        expiration: datetime = None,
        metadata: Dict[str, Any] = None
    ):
        """
        Initialize a new trading signal.
        
        Args:
            strategy_id: ID of the strategy generating the signal
            symbol: Symbol the signal applies to
            action: Action to take (buy, sell, hold, close)
            timestamp: When the signal was generated (defaults to now)
            strength: Strength of the signal
            confidence: Confidence level (0.0 to 1.0)
            target_price: Target price for the order (or None for market)
            stop_loss: Stop loss price
            take_profit: Take profit price
            quantity: Specific quantity to trade
            allocation: Portfolio allocation (0.0 to 1.0) as alternative to quantity
            expiration: When the signal expires (None for default expiration)
            metadata: Additional signal-specific data
        """
        self.id = str(uuid.uuid4())
        self.strategy_id = strategy_id
        self.symbol = symbol
        self.action = action
        self.timestamp = timestamp or datetime.now()
        self.strength = strength
        self.confidence = max(0.0, min(1.0, confidence))  # Clamp to [0.0, 1.0]
        self.target_price = target_price
        self.stop_loss = stop_loss
        self.take_profit = take_profit
        self.quantity = quantity
        self.allocation = allocation
        self.expiration = expiration or (self.timestamp + timedelta(days=1))
        self.metadata = metadata or {}
        self.processed = False
        self.result = None
    
    def is_active(self) -> bool:
        """Check if the signal is still active (not expired and not processed)."""
        return not self.processed and datetime.now() < self.expiration
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary representation."""
        return {
            "id": self.id,
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "action": self.action.value,
            "timestamp": self.timestamp.isoformat(),
            "strength": self.strength.value,
            "confidence": self.confidence,
            "target_price": self.target_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "quantity": self.quantity,
            "allocation": self.allocation,
            "expiration": self.expiration.isoformat(),
            "metadata": self.metadata,
            "processed": self.processed,
            "result": self.result
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Signal':
        """Create a signal from dictionary representation."""
        signal = cls(
            strategy_id=data["strategy_id"],
            symbol=data["symbol"],
            action=SignalAction(data["action"]),
            timestamp=datetime.fromisoformat(data["timestamp"]),
            strength=SignalStrength(data["strength"]),
            confidence=data["confidence"],
            target_price=data.get("target_price"),
            stop_loss=data.get("stop_loss"),
            take_profit=data.get("take_profit"),
            quantity=data.get("quantity"),
            allocation=data.get("allocation"),
            expiration=datetime.fromisoformat(data["expiration"]),
            metadata=data.get("metadata", {})
        )
        signal.id = data["id"]
        signal.processed = data.get("processed", False)
        signal.result = data.get("result")
        return signal


class StrategyEnsemble:
    """
    A collection of strategies that work together to generate combined signals.
    
    The ensemble can use various methods to combine signals from multiple strategies:
    - Weighted voting
    - Unanimous consensus
    - Majority vote
    - Performance-weighted allocation
    """
    
    def __init__(
        self,
        ensemble_id: str,
        name: str,
        strategies: Dict[str, Tuple[Strategy, float]] = None,
        combination_method: str = "weighted",
        min_consensus: float = 0.5,
        auto_adjust_weights: bool = True,
        description: str = ""
    ):
        """
        Initialize a strategy ensemble.
        
        Args:
            ensemble_id: Unique identifier for the ensemble
            name: Human-readable name
            strategies: Dictionary mapping strategy IDs to (strategy, weight) tuples
            combination_method: How to combine signals ("weighted", "unanimous", "majority", "performance")
            min_consensus: Minimum level of agreement required (0.0 to 1.0)
            auto_adjust_weights: Whether to adjust weights based on performance
            description: Detailed description of the ensemble
        """
        self.ensemble_id = ensemble_id
        self.name = name
        self.strategies = strategies or {}
        self.combination_method = combination_method
        self.min_consensus = min_consensus
        self.auto_adjust_weights = auto_adjust_weights
        self.description = description
        self.state = StrategyState.INITIALIZED
        self.signals: List[Signal] = []
        self.symbols: Set[str] = set()
        self.last_weight_adjustment = datetime.now()
        
        # Update symbols set based on member strategies
        self._update_symbols()
    
    def _update_symbols(self) -> None:
        """Update the set of symbols handled by this ensemble."""
        self.symbols = set()
        for strategy, _ in self.strategies.values():
            self.symbols.update(strategy.symbols)
    
    def add_strategy(self, strategy: Strategy, weight: float = 1.0) -> None:
        """
        Add a strategy to the ensemble.
        
        Args:
            strategy: Strategy to add
            weight: Weight for the strategy's signals
        """
        self.strategies[strategy.strategy_id] = (strategy, weight)
        self.symbols.update(strategy.symbols)
        
        logger.info(f"Added strategy {strategy.name} to ensemble {self.name} with weight {weight}")
    
    def remove_strategy(self, strategy_id: str) -> bool:
        """
        Remove a strategy from the ensemble.
        
        Args:
            strategy_id: ID of the strategy to remove
            
        Returns:
            True if the strategy was found and removed, False otherwise
        """
        if strategy_id in self.strategies:
            self.strategies.pop(strategy_id)
            self._update_symbols()
            logger.info(f"Removed strategy {strategy_id} from ensemble {self.name}")
            return True
        return False
    
    def update_weight(self, strategy_id: str, weight: float) -> bool:
        """
        Update the weight of a strategy in the ensemble.
        
        Args:
            strategy_id: ID of the strategy to update
            weight: New weight value
            
        Returns:
            True if the strategy was found and updated, False otherwise
        """
        if strategy_id in self.strategies:
            strategy, _ = self.strategies[strategy_id]
            self.strategies[strategy_id] = (strategy, weight)
            logger.info(f"Updated weight for strategy {strategy_id} in ensemble {self.name} to {weight}")
            return True
        return False
    
    def normalize_weights(self) -> None:
        """Normalize weights so they sum to 1.0."""
        total_weight = sum(weight for _, weight in self.strategies.values())
        if total_weight <= 0:
            # If total weight is zero or negative, set equal weights
            equal_weight = 1.0 / max(1, len(self.strategies))
            self.strategies = {
                strategy_id: (strategy, equal_weight)
                for strategy_id, (strategy, _) in self.strategies.items()
            }
        else:
            # Otherwise normalize
            self.strategies = {
                strategy_id: (strategy, weight / total_weight)
                for strategy_id, (strategy, weight) in self.strategies.items()
            }
    
    def adjust_weights_by_performance(self, performance_metrics: Dict[str, Dict[str, float]]) -> None:
        """
        Adjust weights based on strategy performance.
        
        Args:
            performance_metrics: Dictionary mapping strategy IDs to performance metrics
        """
        if not self.auto_adjust_weights or not performance_metrics:
            return
        
        # Only adjust weights periodically
        now = datetime.now()
        if (now - self.last_weight_adjustment).days < 1:
            return
        
        # Calculate performance score for each strategy
        scores = {}
        for strategy_id, (strategy, current_weight) in self.strategies.items():
            if strategy_id in performance_metrics:
                metrics = performance_metrics[strategy_id]
                # Simple performance score formula
                score = (
                    metrics.get("sharpe_ratio", 0) * 0.4 +
                    metrics.get("profit_factor", 1) * 0.3 +
                    metrics.get("win_rate", 0.5) * 0.2 +
                    metrics.get("expectancy", 0) * 0.1
                )
                scores[strategy_id] = max(0.1, score)  # Ensure minimum weight
            else:
                # No performance data, use current weight
                scores[strategy_id] = current_weight
        
        # Update weights based on scores
        total_score = sum(scores.values())
        if total_score > 0:
            for strategy_id, score in scores.items():
                strategy, _ = self.strategies[strategy_id]
                new_weight = score / total_score
                self.strategies[strategy_id] = (strategy, new_weight)
            
            self.last_weight_adjustment = now
            logger.info(f"Adjusted weights in ensemble {self.name} based on performance")
    
    def start(self) -> None:
        """Start all strategies in the ensemble."""
        for strategy, _ in self.strategies.values():
            if strategy.state != StrategyState.RUNNING:
                strategy.start()
        self.state = StrategyState.RUNNING
    
    def pause(self) -> None:
        """Pause all strategies in the ensemble."""
        for strategy, _ in self.strategies.values():
            if strategy.state == StrategyState.RUNNING:
                strategy.pause()
        self.state = StrategyState.PAUSED
    
    def stop(self) -> None:
        """Stop all strategies in the ensemble."""
        for strategy, _ in self.strategies.values():
            if strategy.state != StrategyState.STOPPED:
                strategy.stop()
        self.state = StrategyState.STOPPED
    
    def is_running(self) -> bool:
        """Check if the ensemble is currently running."""
        return self.state == StrategyState.RUNNING
    
    def generate_combined_signal(self, symbol: str, signals: List[Signal]) -> Optional[Signal]:
        """
        Generate a combined signal from individual strategy signals.
        
        Args:
            symbol: The symbol to generate a signal for
            signals: List of signals from individual strategies
            
        Returns:
            A combined signal or None if no consensus
        """
        if not signals:
            return None
        
        # Filter signals for the specified symbol
        symbol_signals = [s for s in signals if s.symbol == symbol]
        if not symbol_signals:
            return None
        
        # Group signals by action
        action_groups = defaultdict(list)
        for signal in symbol_signals:
            action_groups[signal.action].append(signal)
        
        if self.combination_method == "unanimous":
            # Unanimous method: all strategies must agree
            if len(action_groups) == 1:
                action = next(iter(action_groups))
                return self._create_combined_signal(symbol, action, action_groups[action])
            return None
        
        elif self.combination_method == "majority":
            # Majority method: most strategies must agree
            max_count = 0
            majority_action = None
            for action, action_signals in action_groups.items():
                if len(action_signals) > max_count:
                    max_count = len(action_signals)
                    majority_action = action
            
            # Check if the majority exceeds the minimum consensus threshold
            if majority_action and max_count / len(symbol_signals) >= self.min_consensus:
                return self._create_combined_signal(
                    symbol, majority_action, action_groups[majority_action]
                )
            return None
        
        elif self.combination_method == "performance":
            # Performance method: highest performing strategy's signal
            # This requires external performance metrics
            best_signal = max(symbol_signals, key=lambda s: s.confidence)
            return best_signal
        
        else:  # Default: weighted method
            # Weighted method: weight signals by strategy weights
            weighted_scores = defaultdict(float)
            for signal in symbol_signals:
                strategy_id = signal.strategy_id
                if strategy_id in self.strategies:
                    _, weight = self.strategies[strategy_id]
                    weighted_scores[signal.action] += weight * signal.confidence
            
            # Find action with highest weighted score
            if not weighted_scores:
                return None
            
            best_action = max(weighted_scores.items(), key=lambda x: x[1])
            action, score = best_action
            
            # Check if score exceeds minimum consensus
            total_weight = sum(weight for _, weight in self.strategies.values())
            if score / total_weight >= self.min_consensus:
                return self._create_combined_signal(
                    symbol, action, [s for s in symbol_signals if s.action == action]
                )
            
            return None
    
    def _create_combined_signal(
        self, symbol: str, action: SignalAction, signals: List[Signal]
    ) -> Signal:
        """
        Create a combined signal from a set of agreeing signals.
        
        Args:
            symbol: Symbol to create signal for
            action: Agreed action
            signals: List of signals with the same action
            
        Returns:
            Combined signal
        """
        # Calculate average confidence
        avg_confidence = sum(s.confidence for s in signals) / len(signals)
        
        # Calculate average target price if applicable
        target_prices = [s.target_price for s in signals if s.target_price is not None]
        target_price = sum(target_prices) / len(target_prices) if target_prices else None
        
        # Calculate conservative stop loss
        stop_losses = [s.stop_loss for s in signals if s.stop_loss is not None]
        stop_loss = max(stop_losses) if stop_losses and action == SignalAction.BUY else \
                   min(stop_losses) if stop_losses and action == SignalAction.SELL else None
        
        # Calculate conservative take profit
        take_profits = [s.take_profit for s in signals if s.take_profit is not None]
        take_profit = min(take_profits) if take_profits and action == SignalAction.BUY else \
                     max(take_profits) if take_profits and action == SignalAction.SELL else None
        
        # Calculate strength
        strength = SignalStrength.MODERATE
        if avg_confidence > 0.7:
            strength = SignalStrength.STRONG
        elif avg_confidence < 0.4:
            strength = SignalStrength.WEAK
        
        # Use weighted average for allocation if applicable
        allocations = []
        for signal in signals:
            if signal.allocation is not None and signal.strategy_id in self.strategies:
                _, weight = self.strategies[signal.strategy_id]
                allocations.append((signal.allocation, weight))
        
        allocation = None
        if allocations:
            weighted_sum = sum(alloc * weight for alloc, weight in allocations)
            total_weight = sum(weight for _, weight in allocations)
            allocation = weighted_sum / total_weight if total_weight > 0 else None
        
        # Create the combined signal
        return Signal(
            strategy_id=self.ensemble_id,
            symbol=symbol,
            action=action,
            strength=strength,
            confidence=avg_confidence,
            target_price=target_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            allocation=allocation,
            metadata={"source": "ensemble", "component_signals": len(signals)}
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert ensemble to dictionary representation."""
        return {
            "ensemble_id": self.ensemble_id,
            "name": self.name,
            "strategies": {
                strategy_id: weight
                for strategy_id, (_, weight) in self.strategies.items()
            },
            "combination_method": self.combination_method,
            "min_consensus": self.min_consensus,
            "auto_adjust_weights": self.auto_adjust_weights,
            "description": self.description,
            "state": self.state.value,
            "symbols": list(self.symbols)
        }
